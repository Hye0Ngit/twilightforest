// 
// Decompiled by Procyon v0.6-prerelease
// 

package twilightforest.client.texture;

import net.minecraft.util.math.MathHelper;
import java.util.Iterator;
import twilightforest.TwilightForestMod;
import java.util.Arrays;
import com.google.common.collect.Lists;
import java.util.function.Function;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import net.minecraft.client.resources.IResourceManager;
import net.minecraft.util.ResourceLocation;
import net.minecraft.client.renderer.texture.TextureAtlasSprite;

public class GradientMappedTexture extends TextureAtlasSprite
{
    private final ResourceLocation textureDependency;
    private boolean shouldNormalize;
    private final GradientNode[] GRADIENT_MAP;
    private float minimumValue;
    private float maximumValue;
    
    public GradientMappedTexture(final ResourceLocation textureDependency, final ResourceLocation spriteName, final boolean shouldNormalize, final GradientNode[] gradient_map) {
        super(spriteName.toString());
        this.textureDependency = textureDependency;
        this.GRADIENT_MAP = gradient_map;
        this.shouldNormalize = shouldNormalize;
    }
    
    public boolean hasCustomLoader(final IResourceManager manager, final ResourceLocation location) {
        return true;
    }
    
    public Collection<ResourceLocation> getDependencies() {
        return (Collection<ResourceLocation>)ImmutableList.of((Object)this.textureDependency);
    }
    
    public boolean load(final IResourceManager manager, final ResourceLocation location, final Function<ResourceLocation, TextureAtlasSprite> textureGetter) {
        final TextureAtlasSprite sprite = textureGetter.apply(this.textureDependency);
        this.func_94217_a(sprite);
        this.field_110982_k = sprite.field_110982_k;
        this.field_110976_a = Lists.newArrayList();
        int minimumValue = 255;
        int maximumValue = 0;
        for (int i = 0; i < sprite.func_110970_k(); ++i) {
            final int[][] textureFrom = sprite.func_147965_a(i);
            final int[][] textureTo = new int[textureFrom.length][];
            for (int j = 0; j < textureFrom.length; ++j) {
                textureTo[j] = Arrays.copyOf(textureFrom[j], textureFrom[j].length);
            }
            if (this.shouldNormalize) {
                for (final int pixel : textureTo[0]) {
                    if ((pixel >> 24 & 0xFF) != 0x0) {
                        minimumValue = Math.min(minimumValue, getPerceptualBrightness(pixel));
                        maximumValue = Math.max(maximumValue, getPerceptualBrightness(pixel));
                    }
                }
            }
            this.field_110976_a.add(i, textureTo);
        }
        if (this.shouldNormalize) {
            if (minimumValue > maximumValue) {
                this.minimumValue = maximumValue / 255.0f;
                this.maximumValue = minimumValue / 255.0f;
            }
            else {
                this.minimumValue = minimumValue / 255.0f;
                this.maximumValue = maximumValue / 255.0f;
            }
            for (final int[][] texture : this.field_110976_a) {
                for (int l = 0; l < texture.length; ++l) {
                    for (int j = 0; j < texture[l].length; ++j) {
                        texture[l][j] = getGradient(texture[l][j], this.GRADIENT_MAP, this.minimumValue, this.maximumValue);
                    }
                }
            }
            TwilightForestMod.LOGGER.debug("Autogenerated {} from {} with min value {} and max value {}", (Object)this.func_94215_i(), (Object)this.textureDependency, (Object)this.minimumValue, (Object)this.maximumValue);
        }
        else {
            for (final int[][] texture : this.field_110976_a) {
                for (int l = 0; l < texture.length; ++l) {
                    for (int j = 0; j < texture[l].length; ++j) {
                        texture[l][j] = getGradient(texture[l][j], this.GRADIENT_MAP, 0.0f, 1.0f);
                    }
                }
            }
            TwilightForestMod.LOGGER.debug("Autogenerated {} from {}", (Object)this.func_94215_i(), (Object)this.textureDependency);
        }
        return false;
    }
    
    public static int getGradient(final int packedColor, final GradientNode[] gradientMap, final float minimumValue, final float maximumValue) {
        final int a = packedColor >> 24 & 0xFF;
        if (a == 0) {
            return packedColor;
        }
        final float gray = normalize(getPerceptualBrightness(packedColor) / 255.0f, minimumValue, maximumValue);
        int rTo = 0;
        int gTo = 0;
        int bTo = 0;
        if (gray <= gradientMap[0].node) {
            rTo = red(gradientMap[0].color);
            gTo = green(gradientMap[0].color);
            bTo = blue(gradientMap[0].color);
        }
        else if (gray >= gradientMap[gradientMap.length - 1].node) {
            final int i = gradientMap[gradientMap.length - 1].color;
            rTo = red(i);
            gTo = green(i);
            bTo = blue(i);
        }
        else {
            for (int i = 0; i < gradientMap.length - 1; ++i) {
                if (gray == gradientMap[i].node) {
                    rTo = red(gradientMap[i].color);
                    gTo = green(gradientMap[i].color);
                    bTo = blue(gradientMap[i].color);
                }
                else if (gray >= gradientMap[i].node && gray <= gradientMap[i + 1].node) {
                    return interpolateColors(normalize(gray, gradientMap[i].node, gradientMap[i + 1].node), gradientMap[i].color, gradientMap[i + 1].color, a);
                }
            }
        }
        return getColorFromARGB(rTo, gTo, bTo, a);
    }
    
    public static int interpolateColors(final float placement, final int color1, final int color2, final int alpha) {
        final int r1 = red(color1);
        final int g1 = green(color1);
        final int b1 = blue(color1);
        final int r2 = red(color2);
        final int g2 = green(color2);
        final int b2 = blue(color2);
        return getColorFromARGB(parabolicInterpolation(placement, (float)r1, (float)r2), parabolicInterpolation(placement, (float)g1, (float)g2), parabolicInterpolation(placement, (float)b1, (float)b2), alpha);
    }
    
    public static int parabolicInterpolation(final float placement, final float v1, final float v2) {
        return (int)MathHelper.func_76129_c(v1 * v1 * (1.0f - placement) + v2 * v2 * placement);
    }
    
    public static float normalize(final float valueIn, final float minimumValue, final float maximumValue) {
        return (valueIn - minimumValue) / (maximumValue - minimumValue);
    }
    
    static int red(final int pixel) {
        return pixel >> 16 & 0xFF;
    }
    
    static int green(final int pixel) {
        return pixel >> 8 & 0xFF;
    }
    
    static int blue(final int pixel) {
        return pixel & 0xFF;
    }
    
    static int getColorFromARGB(final int r, final int g, final int b, final int a) {
        return (((a << 8) + r << 8) + g << 8) + b;
    }
    
    private static int getPerceptualBrightness(final int col) {
        return getPerceptualBrightness(red(col) / 255.0, green(col) / 255.0, blue(col) / 255.0);
    }
    
    private static int getPerceptualBrightness(final double r, final double g, final double b) {
        return (int)(Math.sqrt(0.241 * r * r + 0.691 * g * g + 0.068 * b * b) * 255.0);
    }
}
