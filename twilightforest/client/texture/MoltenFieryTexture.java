// 
// Decompiled by Procyon v0.6-prerelease
// 

package twilightforest.client.texture;

import com.google.common.collect.ImmutableList;
import java.util.Collection;
import twilightforest.TwilightForestMod;
import com.google.common.collect.Lists;
import java.util.function.Function;
import net.minecraft.client.resources.IResourceManager;
import net.minecraft.util.ResourceLocation;
import net.minecraft.client.renderer.texture.TextureAtlasSprite;

public class MoltenFieryTexture extends TextureAtlasSprite
{
    private final ResourceLocation textureDependency;
    private float minimumValue;
    private float maximumValue;
    private static final GradientNode[] GRADIENT_MAP;
    
    public MoltenFieryTexture(final ResourceLocation textureDependency, final ResourceLocation spriteName) {
        super(spriteName.toString());
        this.textureDependency = textureDependency;
    }
    
    public boolean hasCustomLoader(final IResourceManager manager, final ResourceLocation location) {
        return true;
    }
    
    public boolean load(final IResourceManager manager, final ResourceLocation location, final Function<ResourceLocation, TextureAtlasSprite> textureGetter) {
        final TextureAtlasSprite sprite = textureGetter.apply(this.textureDependency);
        this.func_94217_a(sprite);
        this.field_110982_k = sprite.field_110982_k;
        this.field_110976_a = Lists.newArrayList();
        int minimumValue = 255;
        int maximumValue = 0;
        for (int i = 0; i < sprite.func_110970_k(); ++i) {
            final int[][] textureFrom = sprite.func_147965_a(i).clone();
            final int[][] textureTo = new int[textureFrom.length][];
            for (int j = 0; j < textureFrom.length; ++j) {
                textureTo[j] = new int[textureFrom[j].length];
                System.arraycopy(textureFrom[j], 0, textureTo[j], 0, textureFrom[j].length);
            }
            for (final int pixel : textureTo[0]) {
                if ((pixel >> 24 & 0xFF) != 0x0) {
                    minimumValue = Math.min(minimumValue, getPerceptualBrightness(pixel));
                    maximumValue = Math.max(maximumValue, getPerceptualBrightness(pixel));
                }
            }
            this.field_110976_a.add(i, textureTo);
        }
        if (minimumValue > maximumValue) {
            this.minimumValue = maximumValue / 255.0f;
            this.maximumValue = minimumValue / 255.0f;
        }
        else {
            this.minimumValue = minimumValue / 255.0f;
            this.maximumValue = maximumValue / 255.0f;
        }
        for (int i = 0; i < this.field_110976_a.size(); ++i) {
            final int[][] texture = this.field_110976_a.get(i);
            for (int l = 0; l < texture.length; ++l) {
                for (int j = 0; j < texture[l].length; ++j) {
                    texture[l][j] = GradientMappedTexture.getGradient(texture[l][j], MoltenFieryTexture.GRADIENT_MAP, this.minimumValue, this.maximumValue);
                }
            }
        }
        TwilightForestMod.LOGGER.debug("Autogenerated {} from {}", (Object)this.func_94215_i(), (Object)this.textureDependency);
        return false;
    }
    
    public Collection<ResourceLocation> getDependencies() {
        return (Collection<ResourceLocation>)ImmutableList.of((Object)this.textureDependency);
    }
    
    private static int getPerceptualBrightness(final int col) {
        return getPerceptualBrightness((col >> 16 & 0xFF) / 255.0, (col >> 8 & 0xFF) / 255.0, (col & 0xFF) / 255.0);
    }
    
    private static int getPerceptualBrightness(final double r, final double g, final double b) {
        return (int)(Math.sqrt(0.241 * r * r + 0.691 * g * g + 0.068 * b * b) * 255.0);
    }
    
    static {
        GRADIENT_MAP = new GradientNode[] { new GradientNode(0.0f, -16251386), new GradientNode(0.2f, -15133933), new GradientNode(0.7f, -12836061) };
    }
}
