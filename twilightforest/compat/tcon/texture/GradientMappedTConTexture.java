// 
// Decompiled by Procyon v0.6-prerelease
// 

package twilightforest.compat.tcon.texture;

import twilightforest.client.texture.GradientMappedTexture;
import slimeknights.tconstruct.library.client.RenderUtil;
import twilightforest.TwilightForestMod;
import net.minecraft.client.renderer.texture.TextureAtlasSprite;
import java.util.function.Function;
import net.minecraft.client.resources.IResourceManager;
import twilightforest.client.texture.GradientNode;
import net.minecraft.util.ResourceLocation;
import slimeknights.tconstruct.library.client.texture.AbstractColoredTexture;

public class GradientMappedTConTexture extends AbstractColoredTexture
{
    private final ResourceLocation textureIn;
    protected GradientNode[] gradientMap;
    protected boolean shouldStretchMinimumMaximum;
    protected float minimumValue;
    protected float maximumValue;
    
    GradientMappedTConTexture(final ResourceLocation baseTextureLocation, final String spriteName, final boolean shouldStretchMinimumMaximum, final GradientNode[] gradientMap) {
        super(baseTextureLocation, spriteName);
        this.shouldStretchMinimumMaximum = shouldStretchMinimumMaximum;
        this.gradientMap = gradientMap;
        this.textureIn = baseTextureLocation;
    }
    
    public boolean load(final IResourceManager manager, final ResourceLocation location, final Function<ResourceLocation, TextureAtlasSprite> textureGetter) {
        TwilightForestMod.LOGGER.debug("Autogenerated {} from {}", (Object)this.func_94215_i(), (Object)this.textureIn);
        return super.load(manager, location, (Function)textureGetter);
    }
    
    protected void preProcess(final int[] data) {
        if (this.shouldStretchMinimumMaximum) {
            int minimumValue = 255;
            int maximumValue = 0;
            for (final int pixel : data) {
                if (RenderUtil.alpha(pixel) != 0) {
                    minimumValue = Math.min(minimumValue, getPerceptualBrightness(pixel));
                    maximumValue = Math.max(maximumValue, getPerceptualBrightness(pixel));
                }
            }
            if (minimumValue > maximumValue) {
                this.minimumValue = maximumValue / 255.0f;
                this.maximumValue = minimumValue / 255.0f;
            }
            else {
                this.minimumValue = minimumValue / 255.0f;
                this.maximumValue = maximumValue / 255.0f;
            }
        }
        else {
            this.minimumValue = 0.0f;
            this.maximumValue = 1.0f;
        }
    }
    
    protected int colorPixel(final int pixel, final int pxCoord) {
        final int a = RenderUtil.alpha(pixel);
        if (a == 0) {
            return pixel;
        }
        final int rFrom = RenderUtil.red(pixel);
        final int gFrom = RenderUtil.green(pixel);
        final int bFrom = RenderUtil.blue(pixel);
        int rTo = 0;
        int gTo = 0;
        int bTo = 0;
        final float gray = this.getModifiedValue((rFrom + gFrom + bFrom) / 765.0f);
        if (gray <= this.gradientMap[0].node) {
            rTo = RenderUtil.red(this.gradientMap[0].color);
            gTo = RenderUtil.green(this.gradientMap[0].color);
            bTo = RenderUtil.blue(this.gradientMap[0].color);
        }
        else if (gray >= this.gradientMap[this.gradientMap.length - 1].node) {
            final int i = this.gradientMap[this.gradientMap.length - 1].color;
            rTo = RenderUtil.red(i);
            gTo = RenderUtil.green(i);
            bTo = RenderUtil.blue(i);
        }
        else {
            for (int i = 0; i < this.gradientMap.length - 1; ++i) {
                if (gray == this.gradientMap[i].node) {
                    rTo = RenderUtil.red(this.gradientMap[i].color);
                    gTo = RenderUtil.green(this.gradientMap[i].color);
                    bTo = RenderUtil.blue(this.gradientMap[i].color);
                }
                else if (gray >= this.gradientMap[i].node && gray <= this.gradientMap[i + 1].node) {
                    return GradientMappedTexture.interpolateColors(GradientMappedTexture.normalize(gray, this.gradientMap[i].node, this.gradientMap[i + 1].node), this.gradientMap[i].color, this.gradientMap[i + 1].color, a);
                }
            }
        }
        return RenderUtil.compose(rTo, gTo, bTo, a);
    }
    
    protected final float getModifiedValue(final float valueIn) {
        if (this.shouldStretchMinimumMaximum) {
            return (valueIn - this.minimumValue) / (this.maximumValue - this.minimumValue);
        }
        return valueIn;
    }
}
