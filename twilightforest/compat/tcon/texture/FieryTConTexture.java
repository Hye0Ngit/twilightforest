// 
// Decompiled by Procyon v0.6-prerelease
// 

package twilightforest.compat.tcon.texture;

import twilightforest.client.texture.GradientMappedTexture;
import twilightforest.TwilightForestMod;
import java.util.List;
import net.minecraft.client.resources.data.AnimationMetadataSection;
import net.minecraft.client.resources.data.AnimationFrame;
import java.util.ArrayList;
import slimeknights.tconstruct.library.TinkerAPIException;
import java.util.Arrays;
import com.google.common.collect.Lists;
import net.minecraft.client.renderer.texture.TextureAtlasSprite;
import java.util.function.Function;
import net.minecraft.client.resources.IResourceManager;
import java.awt.image.DirectColorModel;
import twilightforest.client.texture.GradientNode;
import net.minecraft.util.ResourceLocation;

public class FieryTConTexture extends GradientMappedTConTexture
{
    private final ResourceLocation textureIn;
    private boolean[] translucent;
    private boolean[] edge;
    private static final GradientNode[] outlineColors;
    public static final GradientNode[] innerColors;
    private static final GradientNode[] innerColorsGlow;
    private static final DirectColorModel colorModel;
    
    FieryTConTexture(final ResourceLocation textureIn, final String spriteName) {
        super(textureIn, spriteName, true, FieryTConTexture.innerColors);
        this.textureIn = textureIn;
    }
    
    @Override
    public boolean load(final IResourceManager manager, final ResourceLocation location, final Function<ResourceLocation, TextureAtlasSprite> textureGetter) {
        this.field_110976_a = Lists.newArrayList();
        this.field_110973_g = 0;
        this.field_110983_h = 0;
        final TextureAtlasSprite baseTexture = textureGetter.apply(this.textureIn);
        if (baseTexture == null || baseTexture.func_110970_k() <= 0) {
            this.field_130223_c = 1;
            this.field_130224_d = 1;
            return false;
        }
        this.func_94217_a(baseTexture);
        final int[][] original = baseTexture.func_147965_a(0);
        final int[][] data = new int[original.length][];
        final int[][] dataSecondFrame = new int[original.length][];
        data[0] = Arrays.copyOf(original[0], original[0].length);
        dataSecondFrame[0] = Arrays.copyOf(original[0], original[0].length);
        try {
            this.preProcess(data[0]);
            for (int pxCoord = 0; pxCoord < data[0].length; ++pxCoord) {
                data[0][pxCoord] = this.colorPixel(data[0][pxCoord], pxCoord);
                this.gradientMap = FieryTConTexture.innerColorsGlow;
                dataSecondFrame[0][pxCoord] = this.colorPixel(dataSecondFrame[0][pxCoord], pxCoord);
                this.gradientMap = FieryTConTexture.innerColors;
            }
        }
        catch (Exception e) {
            throw new TinkerAPIException("Error occured while processing: " + this.func_94215_i(), (Throwable)e);
        }
        if (this.field_110976_a.isEmpty()) {
            this.field_110976_a.add(data);
            this.field_110976_a.add(dataSecondFrame);
        }
        final List<AnimationFrame> frames = new ArrayList<AnimationFrame>();
        frames.add(new AnimationFrame(0));
        frames.add(new AnimationFrame(1));
        this.field_110982_k = new AnimationMetadataSection((List)frames, this.field_130223_c, this.field_130224_d, 18, true);
        TwilightForestMod.LOGGER.debug("Autogenerated {} from {}", (Object)this.func_94215_i(), (Object)this.textureIn);
        return false;
    }
    
    @Override
    protected void preProcess(final int[] data) {
        this.edge = new boolean[this.field_130223_c * this.field_130224_d];
        this.translucent = new boolean[this.field_130223_c * this.field_130224_d];
        for (int x = 0; x < this.field_130223_c; ++x) {
            for (int y = 0; y < this.field_130224_d; ++y) {
                if (x == 0 || y == 0 || x == this.field_130223_c - 1 || y == this.field_130224_d - 1) {
                    this.edge[this.coord(x, y)] = true;
                }
                final int c = data[this.coord(x, y)];
                if (c == 0 || FieryTConTexture.colorModel.getAlpha(c) < 64) {
                    this.translucent[this.coord(x, y)] = true;
                    if (x > 0) {
                        this.edge[this.coord(x - 1, y)] = true;
                    }
                    if (y > 0) {
                        this.edge[this.coord(x, y - 1)] = true;
                    }
                    if (x < this.field_130223_c - 1) {
                        this.edge[this.coord(x + 1, y)] = true;
                    }
                    if (y < this.field_130224_d - 1) {
                        this.edge[this.coord(x, y + 1)] = true;
                    }
                }
            }
        }
        int minimumValue = 255;
        int maximumValue = 0;
        for (int i = 0; i < data.length; ++i) {
            final int pixel = data[i];
            if (!this.edge[i] && !this.translucent[i]) {
                minimumValue = Math.min(minimumValue, getPerceptualBrightness(pixel));
                maximumValue = Math.max(maximumValue, getPerceptualBrightness(pixel));
            }
        }
        if (minimumValue > maximumValue) {
            this.minimumValue = maximumValue / 255.0f;
            this.maximumValue = minimumValue / 255.0f;
        }
        else {
            this.minimumValue = minimumValue / 255.0f;
            this.maximumValue = maximumValue / 255.0f;
        }
    }
    
    @Override
    protected int colorPixel(final int pixel, final int pxCoord) {
        if (!this.translucent[pxCoord] && this.edge[pxCoord]) {
            final short ff = 255;
            final int x = this.getX(pxCoord) * 255 / this.field_130223_c;
            final int y = this.getY(pxCoord) * 255 / this.field_130224_d;
            final int gray = this.hashCode() + x - y & ff;
            return GradientMappedTexture.getGradient(ff << 24 | gray << 16 | gray << 8 | gray, FieryTConTexture.outlineColors, 0.0f, 1.0f);
        }
        return super.colorPixel(pixel, pxCoord);
    }
    
    static {
        outlineColors = new GradientNode[] { new GradientNode(0.0f, -1), new GradientNode(0.125f, -1386), new GradientNode(0.375f, -283356), new GradientNode(0.5f, -289244), new GradientNode(0.625f, -283356), new GradientNode(0.875f, -1386), new GradientNode(1.0f, -1) };
        innerColors = new GradientNode[] { new GradientNode(0.1f, -12836061), new GradientNode(0.7f, -15133933), new GradientNode(0.9f, -16251386) };
        innerColorsGlow = new GradientNode[] { new GradientNode(0.1f, -8964847), new GradientNode(0.7f, -10081015), new GradientNode(0.9f, -10672637) };
        colorModel = new DirectColorModel(32, 16711680, 65280, 255, -16777216);
    }
}
